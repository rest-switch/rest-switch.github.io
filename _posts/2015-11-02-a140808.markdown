---
layout:     post-toc
title:      Hey Kids! Grow giant open source IoT controllers in your own basement!
subtitle:   Using off-the-shelf industrial-grade commodity hardware for sophisticated Internet of Things applications.
excerpt:    This is an open source project to connect an high durability but inexpensive 8 opto-isolated input / 8 relay output WiFi and Ethernet enabled controller via an encrypted websocket connection to the Internet. The configuration features an extremely low latency command and control architecture using Nginx or Redis based pubsub.
image:      businessman.png
image-px:   250
date:       2015-11-02 05:24:42 -0500
author:     John Clark
categories: a140808 iot opensource
---

<a class="anchor" id="introduction"></a>
<span>&nbsp;</span>

###Introduction
This is an open source project to connect an high durability yet inexpensive 8 opto-isolated input / 8 relay output WiFi and Ethernet enabled controller via an encrypted websocket connection to the Internet. The configuration features an extremely low latency command and control architecture using Nginx or Redis based pubsub. The result is a high quality yet extremely low cost solution with a huge number of IoT applications such as: simple on/off control, one-shot activation of devices like garage doors, state monitoring, Internet home thermostat, burglar alarm, and sprinkler system control to name only a few. The goal is to create an open source ecosystem of inexpensive commodity hardware and application software for a wide range of IoT command and control applications.

<span>&nbsp;</span>

**Physical Inspection**

The device used in this project is available from AliExpress for approximately $65 at the time of this writing. It comes with no useful documentation and its factory configuration is of limited value. There is no model number, so I decided to call it the A140808 which encodes the fact that I first bought it in 2014 and it has 08 inputs and 08 outputs.

<span>&nbsp;</span>
<center><table style="border-spacing: 10px; border-collapse: separate; font-size: 90%">
<tr><td><img width="500px" src="/images/f1_enclosure.jpg" /></td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Figure 1: The A140808 Device Enclosure with WiFi Antenna</td></tr>
</table></center>
<span>&nbsp;</span>

Upon examination of the outside of the device, we see that like most industrial automation equipment, it supports a wide range of voltages from 7v to 28v (Figure 1). Notice it does not specify AC or DC (examination of the buck converter later on shows that it is DC only).

The back of the enclosure (Figure 2) reveals more signs of its industrial automation purpose with the EN 50022 DIN mounting hardware.

<span>&nbsp;</span>
<center><table style="border-spacing: 10px; border-collapse: separate; font-size: 90%">
<tr><td><img width="450px" src="/images/f2_din.jpg" /></td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Figure 2: The A140808 DIN Mounting Clips</td></tr>
</table></center>
<span>&nbsp;</span>

**Teardown**

Removing the cover of the A140808 reveals two major components (Figure 3). The first is the main IO board sporting an <a href="http://www.atmel.com/Images/Atmel-8155-8-bit-Microcontroller-AVR-ATmega32A_Datasheet.pdf" target="_blank">Atmel ATmega32A</a> microcontroller. The ATmega32A is used to monitor the 8 opto-isolated inputs and to control the 8 relay outputs. The second major component is the <a href="http://www.hlktech.net/product_detail.php?ProId=39" target="_blank">Hi-Link HLK-RM04</a> Ethernet/WiFi/Serial module which runs embedded Linux. The brains of the HLK-RM04 is an Ralink RT5350 SOC clocked at 360MHz. Ralink was purchased by MediaTek in 2011 and documentation for the SOC became very difficult to find for some reason. Fortunately, Jiapeng Li has created <a href="https://github.com/JiapengLi" target="_blank">OpenWRT support</a> for the HLK-RM04 module we will lean on later in the article.

<span>&nbsp;</span>
<center><table style="border-spacing: 10px; border-collapse: separate; font-size: 90%">
<tr><td><img width="600px" src="/images/f3_comp.jpg" /></td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Figure 3: Components of the A140808</td></tr>
</table></center>
<span>&nbsp;</span>

Removing the socketed HLK-RM04 reveals the Atmel ATmega32A microcontroller (figure 4). Note that the microcontroller also has a six pin ICSP programming header for our convenience. Unfortunately the header pinout is NOT AVR-ICSP compatible, so we will be building a custom wiring harness later on. It is also worth noting that the ATmega32A is very similar to the ATmega328P used on the Arduino UNO and the ATmega32U4 used on the Arduino Leonardo. We will be using the Arduino SDK to program this chip later on.

<span>&nbsp;</span>
<center><table style="border-spacing: 10px; border-collapse: separate; font-size: 90%">
<tr><td><img width="650px" src="/images/f4_prog.jpg" /></td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Figure 4: Atmel ATmega32A and Six Pin Programming Header</td></tr>
</table></center>
<span>&nbsp;</span>

Looking at what all is included in this commercial quality device with WiFi, Ethernet, Ralink RT5350 SOC, Atmel ATmega32A, 8 opto-isolated inputs, 8 relay outputs, screw terminal connectors, DIN mounts, and a wide input voltage range of 7-28VDC, the A140808 is an incredible platform for open source IoT projects.

<a class="anchor" id="getting_started"></a>
<span>&nbsp;</span>

###Getting Started

<br/>**Linux Build Environment**

The makefiles and shell scripts for this project are written for Linux. If you are not already setup to use Linux, the easiest way to do so is to either use <a href="https://www.virtualbox.org" target="_blank">VirtualBox</a> with <a href="https://www.vagrantup.com" target="_blank">Vagrant</a> or use the <a href="https://aws.amazon.com/free" target="_blank">Amazon AWS Free Tier</a> to build this project. Linux distributions such as Debian, Ubuntu, RedHat, CentOS, and Amazon Linux are all excellent choices and each are similarly easy to use for this project. It is beyond the scope of this document to provide information on setting up or using Linux. If you are unfamiliar with Linux, it is best to get a friend to help you out or read one of the <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EC2_GetStarted.html" target="_blank">excellent tutorials</a> found online.

<span>&nbsp;</span>

Ubuntu Trusty 14.04 requires the following prerequisites:

{% highlight sh %}
sudo apt-get update && sudo apt-get upgrade
sudo apt-get install make gcc g++ libncurses5-dev zlib1g-dev unzip git subversion docker
{% endhighlight %}

Amazon Linux requires the following prerequisites:

{% highlight sh %}
sudo yum update
sudo yum install gcc gcc-c++ ncurses-devel zlib-devel patch  perl\(Data::Dumper\) git subversion docker
{% endhighlight %}

**Known Issues**

 - Ubuntu Wily Werewolf 15.10 is known to have issues building the forked version of OpenWRT used in this project. Use version 15.04 or another version of Linux.

<a class="anchor" id="security_first"></a>
<span>&nbsp;</span>

###Security First

Comprehensive security is a primary concern of IoT applications. This project utilizes well established RSA asymmetric encryption deployed with high strength 4096 bit keys. Additionally, the signed URL design combines HMAC hashing using the high security SHA256 algorithm (HMAC-SHA256) and are narrowly limited in time. In the near future the signed URL implementation will also add adaptive complexity and salting similar to that which is found in the <a href="https://en.wikipedia.org/wiki/Bcrypt" target="_blank">bcrypt</a> key derivation function implementation.

The first step is to generate a self-signed Certificate Authority (CA) which will be built into the A140808 client device, smart phone client devices (TODO: doc custom smartphone CA), as well as the server. This approach allows us to sign our own certificates and establish a tight client-server security contract extremely resistant to <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" target="_blank">man-in-the-middle-attacks</a>. Not only is this approach free, if properly deployed, it can be more secure than using a 3rd party CA that is susceptible to <a href="https://en.wikipedia.org/wiki/DigiNotar" target="_blank">hacking</a> or <a href="https://googleonlinesecurity.blogspot.com/2015/03/maintaining-digital-certificate-security.html" target="_blank">improper management</a>, or <a href="http://www.pcworld.com/article/249510/trustwave_admits_issuing_maninthemiddle_digital_certificate_mozilla_debates_punishment.html" target="_blank">poor judgement</a>. However, it is important to note that the certificate strategy does not preclude the use of certificates signed by well-known CAs.

<br/>**Generate the Certificate Authority**

If you are comfortable generating your own self-signed CA and a certificate signed by this CA, do so now. Alternatively, you can use the two helper scripts gen_ca.sh and gen_cert.sh to simplify this process. Begin by downloading the scripts to a Linux machine:

{% highlight sh %}
wget -O certs.tar.gz https://github.com/rest-switch/stuff/archive/master.tar.gz
tar xzvf certs.tar.gz
cd stuff-master/certs
{% endhighlight %}

Generate the self-signed CA by specifying the CA organization name. The script will default to  a key length setting of 4096 bits and a 10 year expiration. Use the --help command line switch to view the syntax for overriding these default options.

{% highlight sh %}
    ./gen_ca.sh "Acme Co"
{% endhighlight %}

When the script completes, it will emit the name of the public and private CA keys that were generated. This CA will be used to sign the certificate in the next step.

{% highlight sh %}
--> generated ca public cert:  acme-co_ca_public.cer
--> generated ca private key:  acme-co_ca_private
{% endhighlight %}

**Generate the Certificate**

The certificate that will be used to encrypt the websocket and https traffic to the web server requires specific information. It is not necessary to generate the certificate public / private key pair at this time, but if the web server domain name(s) are known, it is a convenient time to do so now using the gen_cert.sh script.

For example, to connect to the server using example.com, ws.example.com, and www.example.com, use the following syntax (see the --help command line switch to view all of the command line options):

{% highlight sh %}
./gen_cert.sh -o "Acme Co" -d example.com -a "example.com ws.example.com www.example.com" -c "San Diego" -s CA -u acme-co_ca_public.cer -v acme-co_ca_private
{% endhighlight %}

When the script completes, it will emit the name of the public and private keys that were generated. For convenience, the script also emits a combined public certificate / CA chain file suitable for use with Nginx:

{% highlight sh %}
--> generated cert public cert:  acme-co_cert_public.cer
--> generated cert public cert chain:  acme-co_cert_chain_public.cer
--> generated cert private key:  acme-co_cert_private
{% endhighlight %}

The certificates needed for the entire project are now generated. It is easy to come back and generate new certificates as needed. It should also be noted that the A140808 device is setup to use multiple CAs and more than one can be generated at this point if so desired.

In the next step, the A140808 device image will be built and the public CA file(s) generated in this step will become part of the device firmware image itself. The details are provided in the next section, but for reference the firmware root CA staging directory is:

{% highlight sh %}
device_a140808-master/hlk-rm04/ca_certs
{% endhighlight %}

**Certificate Review**

In summary, the following certificate files and their use are as follows:

> <code style="font-size: 14px; padding: 6px 10px; margin: 0px 0px 10px">--&gt; generated ca public cert:  acme-co_ca_public.cer</code>
>
> The public certificate for the CA. This is used to validate the identity of subordinate certificates in the trust chain. In the case of this project both the A140808 device and the web server need to have access to a genuine copy of this certificate file.

> <code style="font-size: 14px; padding: 6px 10px; margin: 0px 0px 10px">--&gt; generated ca private key:  acme-co_ca_private</code>
>
> The private certificate for the CA. This certificate is only used to sign certificate signing requests (CSRs). The privacy of this key is paramount to the integrity of the entire certificate trust chain and should be securely stored <a href="https://www.thawte.com/code-signing/whitepaper/best-practices-for-code-signing-certificates.pdf" target="_blank">using best practices</a>.

> <code style="font-size: 14px; padding: 6px 10px; margin: 0px 0px 10px">--&gt; generated cert public cert:  acme-co_cert_public.cer</code>
>
> This is the main public certificate is used to encrypt data between the client and the server. Clients need to trust the CA that signed this certificate or trust the certificate itself if it is a self-signed certificate.

> <code style="font-size: 14px; padding: 6px 10px; margin: 0px 0px 10px">--&gt; generated cert public cert chain:  acme-co_cert_chain_public.cer</code>
>
> This file is a combination of the public certificate and the public root CA certificates suitable for loading in Nginx. The point of this file is to be able to supply the non-well-known public certificate trust chain to clients at connect time.

> <code style="font-size: 14px; padding: 6px 10px; margin: 0px 0px 10px">--&gt; generated cert private key:  acme-co_cert_private</code>
>
> The private certificate key for decrypting SSL communication at the server. This file must be present and kept secret on the web server.

Make a note of where these files are located as they will be used in the next steps to build the A140808 firmware and will be deployed with the Nginx web server Docker container.

<a class="anchor" id="building_firmware"></a>
<span>&nbsp;</span>

###Building the Firmware

<br/>**Project Repository**

Download the A140808 github repository and extract it:

{% highlight sh %}
wget -O device_a140808.tar.gz https://github.com/rest-switch/device_a140808/archive/master.tar.gz
tar xzvf device_a140808.tar.gz
cd device_a140808-master
{% endhighlight %}

The repository contains two subdirectories. The avr directory contains the complete project for building the firmware for the Atmel ATmega32A. Likewise, the hlk-rm04 directory contains the complete project for building the firmware for the Hi-Link HLK-RM04 module.

{% highlight sh %}
[device_a140808-master]$ ls -al
drwxrwxr-x 3 ec2-user ec2-user 4096 Oct  8 14:26 avr
drwxrwxr-x 5 ec2-user ec2-user 4096 Oct  8 14:26 hlk-rm04
-rw-rw-r-- 1 ec2-user ec2-user 1016 Oct  8 14:26 Makefile
-rw-rw-r-- 1 ec2-user ec2-user 1200 Oct  8 14:26 README.md
{% endhighlight %}

Executing make in the <code>device_a140808-master</code> directory will build both projects, or you can descend into either directory and execute <code>make</code> to build that project alone.


<br/>**Building the Atmel ATmega32A Firmware**

Switch to the <code>device_a140808-master/avr</code> directory and type <code>make</code>. The build will complete very quickly and the target binaries will be placed into the <code>bin</code> directory. The files of interest are <code>a140808.hex</code> or <code>a140808.bin</code> depending on the programmer used to flash the device.

{% highlight sh %}
[avr]$ ls -al bin
-rwxrwxr-x 1 ec2-user ec2-user  32768 Oct 23 19:14 a140808.bin
-rw-rw-r-- 1 ec2-user ec2-user     13 Oct 23 19:14 a140808.eep
-rwxrwxr-x 1 ec2-user ec2-user  51387 Oct 23 19:14 a140808.elf
-rw-rw-r-- 1 ec2-user ec2-user  14999 Oct 23 19:14 a140808.hex
-rw-rw-r-- 1 ec2-user ec2-user 141167 Oct 23 19:14 a140808.lss
-rw-rw-r-- 1 ec2-user ec2-user  34626 Oct 23 19:14 a140808.map
-rw-rw-r-- 1 ec2-user ec2-user  36320 Oct 23 19:14 avr_impl.o
-rw-rw-r-- 1 ec2-user ec2-user   2825 Oct 23 19:14 avr_impl.o.dep
-rw-rw-r-- 1 ec2-user ec2-user  41412 Oct 23 19:14 avr_main.o
-rw-rw-r-- 1 ec2-user ec2-user   2996 Oct 23 19:14 avr_main.o.dep
-rw-rw-r-- 1 ec2-user ec2-user     55 Oct 23 19:14 fuses.conf
-rw-rw-r-- 1 ec2-user ec2-user  26808 Oct 23 19:14 serial.o
-rw-rw-r-- 1 ec2-user ec2-user   2452 Oct 23 19:14 serial.o.dep
{% endhighlight %}

In a subsequent section, the source files and theory of operation will be discussed in greater detail. However, at this point this is all that is needed to be able to flash the ATmega32A device. Building the HLK-RM04 device is up next.

<br/>**Building the Atmel HLK-RM04 Firmware**

The Hi-Link HLK-RM04 module runs OpenWRT Linux. Additional information on OpenWRT and the Hi-Link device can be found on the OpenWRT wiki. Before building the firmware, the CA certificates build previously need to be copied to the project directory to be included in the resulting firmware image. Change to the device_a140808-master/hlk-rm04 directory and list the files.

{% highlight sh %}
[hlk-rm04]$ ls -al
drwxrwxr-x  2 ec2-user ec2-user 4096 Oct 23 10:10 ca_certs
drwxrwxr-x  3 ec2-user ec2-user 4096 Oct 23 10:03 files
drwxrwxr-x  2 ec2-user ec2-user 4096 Oct 23 10:03 firmware
-rw-rw-r--  1 ec2-user ec2-user 8442 Oct 23 10:03 Makefile
drwxrwxr-x 15 ec2-user ec2-user 4096 Oct 23 12:18 openwrt-master
drwxrwxr-x  5 ec2-user ec2-user 4096 Oct 23 10:03 tools
{% endhighlight %}

**Copy CA Public Certificates**

Take note of the <code>ca_certs</code> directory which is the location where the CA certificate that were generated earlier belong. Note that the firmware image only requires the public CA file(s). The build script will copy all files ending in <code>_ca_public.cer</code> to the firmware image so following this naming convention is required.

<br/>**SSH Access**

Next, the type of SSH access for the device needs to be considered. It is also possible to configure no SSH access. Certificates based SSH authentication is considered more secure, but password based authentication is also available. It is possible to configure both types of authentication then lockout the password based authentication mechanism at a later time as well. There is no great way to recover access if the certificate is lost or the password is forgotten, so regaining access would require reflashing the firmware. This is an open source project, and OpenWRT does make provisions for password recovery, so this could make a nice enhancement to the project. In general, questions regarding the HLK-RM04 device can easily be searched on the OpenWRT website.

On the command line, include one or more of the options desired. For example, to compile with password access and have the build process prompt (pmt) for the password, type:
{% highlight sh %}
make sshpw=pmt
{% endhighlight %}

To configure a password directly (“mysecret” in this example) and to bundle a newly generated SSH cert file, type:
{% highlight sh %}
make sshpw=mysecret sshcert=gen
{% endhighlight %}

Note that some options are mutually exclusive with each other. The full listing of options is as follows:
{% highlight sh %}
no ssh access: ssh=none
no ssh password access: sshpw=none
ssh password access (prompt): sshpw=pmt
ssh password access: sshpw=<password>
no ssh certificate access: sshcert=none
ssh certificate access, create new cert: sshcert=gen
ssh certificate access, use existing cert: sshcert=<filespec>
{% endhighlight %}

**Note:** If the build fails early before the .config configuration file can be generated, it is possible to get stuck at the Linux kernel config (blue) menu. You should never see this menu in a normal build. If this happens run a make distclean and restart the build from scratch.

**Tip:** Long-running builds will fail if the terminal session gets disconnected. Launch the screen utility to allow the build to continue even of the terminal session becomes disconnected. If the terminal session does become detached, reconnect to the Linux host and execute screen -r to reattach to the running session.

After the build finishes successfully, the firmware file <code>openwrt-ramips-rt305x-hlk-rm04-squashfs-sysupgrade.bin</code> will be placed into the bin directory. For details on the sysupgrade.bin file, refer to the <a href="http://wiki.openwrt.org/doc/howto/generic.sysupgrade" target="_blank">OpenwWRT wiki</a>. The sysupgrade file does not include a bootloader, so it can only be used to update an already running A140808 device. In the later sections of the documentation, instructions for doing so are included. In the case of a new device, it is necessary to build a full firmware image which takes a few more steps.

<br/>**Adding u-boot**

In order to be able to flash the device using a flash programmer, a complete firmware image file is required. In this case, the u-boot that ships with the HLK-RM04 can be used in conjunction with the MAC addresses printed on the front of the device (Figure 5).

<span>&nbsp;</span>
<center><table style="border-spacing: 10px; border-collapse: separate; font-size: 90%">
<tr><td><img width="350px" src="/images/f5_hlkrm04.jpg" /></td></tr>
<tr><td>Figure 5: The HLK-RM04 Module with MAC Addresses</td></tr>
</table></center>
<span>&nbsp;</span>

Notice that the MAC addresses are consecutive. To specify a MAC address and generate the full image firmware, use the <code>make image mac=aabbccddeeff</code> command and specify the first MAC address listed on your device (the build script will assume the second address). For example:

{% highlight sh %}
make image mac=aca213b54a3e
{% endhighlight %}

This will generate a full image firmware file with a unique serial number, for example:

{% highlight sh %}
bin/a140808_akbmkzh80.bin
{% endhighlight %}

The serial number is a nine character alphanumeric code following the underscore. In the case above, the serial number is <code>akbmkzh80</code>. Each time a firmware is emitted, a unique serial number will be generated. Yours will be different than the one shown in this example. Record this numnber and affix it to the outside of the device, it will be used later to uniquely identify the device when it connects to the cloud.

The firmware generation for the HLM-RM04 is now complete. In the next section the firmware for the two chips will be written to their respective devices.

<a class="anchor" id="flashing_firmware"></a>
<span>&nbsp;</span>

###Flashing the Firmware

<br/>**Programmers**

The firmware for both the Atmel ATmega32A chip and the Hi-Link HLK-RM04 module need to be reflashed for this project. A very popular programmer for Atmel chips is the <a href="http://www.atmel.com/tools/AVRISPMKII.aspx" target="_blank">AVRISP mkII programmer</a>. Flashing the firmware to the Atmel device is straightforward and can be done via the six pin programming header located on the circuit board (see Figure 4). Note that the pinout of the six pin programming header is different than the standard AVRISP pinout.

Programming the HLK-RM04 is more difficult. Although it should be possible to reprogram the device via its programming header or by software, that route is not documented and the device is easy to brick. Empirical testing revealed that it was much easier and foolproof to write directly to the flash memory located on the bottom of the module using the <a href="http://www.autoelectric.cn/EN/TL866_main.html" target="_blank">Autoelectric MiniPro TL866A</a> universal programmer and an <a href="http://www.aliexpress.com/item/TL866A-Universal-Programmer-Support-Over-13000-Chips-USB-Programmer-with-4PCS-Socket-and-IC-Picker-Free/1378818625.html" target="_blank">8 pin SOIC test clip</a>. This technique is also agnostic to a bricked device so it will always work in all circumstances.

An added bonus of the Minipro TL866A model is that it has a six pin ICSP programming interface that can flash Atmel chips via the ICSP programming header located on the A140808 board (Figure 4). This makes it the only programmer needed for the entire project. Support for both the AVRISP mkII and the TL866A programmers are included in the supplied project makefiles.

**Note:** There are two models of the MiniPro TL866: The TL866A provides support for flashing Atmel chips via a six pin ICSP programming interface on the front. The less expensive TL866CS model does not include this ICSP interface and thus will require a second programmer for the Atmel device such as the AVRISP mkII.

<br/>**Atmel ATmega32A Programming with AVRISP mkII**

<p style="margin: 0"><span>&nbsp;</span></p>

The Atmel AVRISP mkII programmer uses Atmel’s AVRISP pinout (Figure 6).

<p style="margin: 0"><span>&nbsp;</span></p>
<center>
  <table border="1" style="font-size: 90%">
    <col width="110"><col width="110">
    <tr><td style="padding: 5pt">&nbsp;&nbsp;1 – MISO</td><td style="padding: 5pt">&nbsp;&nbsp;2 – VCC</td></tr>
    <tr><td style="padding: 5pt">&nbsp;&nbsp;3 – SCK</td><td style="padding: 5pt">&nbsp;&nbsp;4 – MOSI</td></tr>
    <tr><td style="padding: 5pt">&nbsp;&nbsp;5 – RESET</td><td style="padding: 5pt">&nbsp;&nbsp;6 – GND</td></tr>
  </table>
  <p style="margin: 10pt"><span>Figure 6: Atmel AVRISP Pinout</span></p>
</center>

<span>&nbsp;</span>

The A140808 proprietary ICSP programming header pinout (Figure 7).

<p style="margin: 0"><span>&nbsp;</span></p>
<center>
  <table border="1" style="font-size: 90%">
    <col width="110"><col width="110">
    <tr><td style="padding: 5pt">&nbsp;&nbsp;1 – GND</td><td style="padding: 5pt">&nbsp;&nbsp;2 – VCC</td></tr>
    <tr><td style="padding: 5pt">&nbsp;&nbsp;3 – RESET</td><td style="padding: 5pt">&nbsp;&nbsp;4 – MOSI</td></tr>
    <tr><td style="padding: 5pt">&nbsp;&nbsp;5 – MISO</td><td style="padding: 5pt">&nbsp;&nbsp;6 – SCK</td></tr>
  </table>
  <p style="margin: 10pt"><span>Figure 7: A140808 AVR Programming Header Pinout</span></p>
</center>

<span>&nbsp;</span>

Programming the Atmel chip using the AVRISP mkII is very straightforward and easy to do. Ideally a custom male-male crossover cable would be built to remap the pins between the programmer and the A140808 programming header. However, since programming the A140808 is likely a one-time operation for most people, using jumper wires is going to make sense for most people. Both approaches are discussed below.

The custom male-male crossover cable approach uses standard female-female jumper wires and a standard six pin IDC female housings to yield the desired pin remappings. This creates a cable with two female ends. Next, the genders at each end are inverted using male-to-male IDC headers which can be super glued into the crossover cable IDC housings. Tip: A metallic silver Sharpie pen can be used to mark pin 1 on each end of the housing.

<p style="margin: 0"><span>&nbsp;</span></p>
<center>
  <table border="1" style="font-size: 90%">
    <col width="210"><col width="310">
    <tr style="color: #fff; background-color: #000; text-align: center"><td style="padding: 5pt">DigiKey Part Number</td><td style="padding: 5pt">Description</td></tr>
    <tr><td style="padding: 5pt">&nbsp;&nbsp;929665-02-03-ND</td><td style="padding: 5pt">&nbsp;&nbsp;6 Pin Male-Male IDC Header</td></tr>
    <tr><td style="padding: 5pt">&nbsp;&nbsp;952-2031-ND</td><td style="padding: 5pt">&nbsp;&nbsp;6 Pin Female Crimp IDC Housing</td></tr>
    <tr><td style="padding: 5pt">&nbsp;&nbsp;1471-1230-ND</td><td style="padding: 5pt">&nbsp;&nbsp;150mm Female-Female Jumper Wire</td></tr>
  </table>
  <p style="margin: 10pt"><span>Table 1: Crossover Cable DigiKey Part Numbers</span></p>
</center>
<span>&nbsp;</span>

The completed conversion is shown in Figure 8. Notice that in this case heat shrink tubing has been used to secure the crossover cable to the programmer.

<p style="margin: 0"><span>&nbsp;</span></p>
<center><table style="border-spacing: 10px; border-collapse: separate; font-size: 90%">
<tr><td><img width="650px" src="/images/f8_harn.jpg" /></td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Figure 8: AVRISP mkII Programmer and Custom Crossover Cable</td></tr>
</table></center>
<span>&nbsp;</span>

Another approach is to use jumper wires for a one-time patch connection. It is worth noting that most off-the-shelf jumper wires are designed for use with breadboards and their pins are very narrow in diameter. The sockets of the female headers are designed to mate with square pin IDC type pins.  Schmartboard Inc. makes jumper wires with these IDC square pin connectors. <a href="http://schmartboard.com/schmartboard-qty-10-7-male-jumpers" target="_blank">Schmartboard part number 920-0099-01</a> is a 10 pack of 7” jumpers that work very well in this application. This part can be sourced from <a href="http://www.mouser.com/search/ProductDetail.aspx?R=0virtualkey0virtualkey920-0099-01" target="_blank">Mouser Electronics</a>.

<br/>**Autoelectric MiniPro TL866A**

The Autoelectric MiniPro TL866A programmer is two programmers in one. The TL866 “A” model has a six pin ICSP programming header that is very easy to reconfigure for programming the A140808. The pinout of the MiniPro ICSP interface (Figure 9) reveals that pins one and three are swapped between it and the A140808 device (compare with Figure 7). In this case, removing the connections from the MiniPro linear header and placing them in a 2x3 IDC housing (DigiKey 952-2031-ND) and changing the gender (DigiKey 929665-02-03-ND) is all that that is required.

<p style="margin: 0"><span>&nbsp;</span></p>
<center>
  <table border="1" style="font-size: 90%">
    <col width="110"><col width="110"><col width="110"><col width="110"><col width="110"><col width="110">
    <tr style="text-align: center">
      <td style="padding: 5pt">1 – RESET</td><td style="padding: 5pt">2 – VCC</td>
      <td style="padding: 5pt">3 – GND</td><td style="padding: 5pt">4 – MOSI</td>
      <td style="padding: 5pt">5 – MISO</td><td style="padding: 5pt">6 – SCK</td>
    </tr>
  </table>
  <p style="margin: 10pt"><span>Figure 9: MiniPro ICSP Pinout</span></p>
</center>
<span>&nbsp;</span>

The completed cable modification is shown in Figure 10.

<p style="margin: 0"><span>&nbsp;</span></p>
<center><table style="border-spacing: 10px; border-collapse: separate; font-size: 90%">
<tr><td><img width="650px" src="/images/f10_mini_isp.jpg" /></td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Figure 10: MiniPro ICSP Cable (Left: Original, Right: Modified)</td></tr>
</table></center>
<span>&nbsp;</span>

<p style="margin: 0"><span>&nbsp;</span></p>
<center><table style="border-spacing: 10px; border-collapse: separate; font-size: 90%">
<tr><td><img width="650px" src="/images/f11_mini.jpg" /></td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Figure 11: MiniPro TL866A with Modified Six Pin ICSP</td></tr>
</table></center>
<span>&nbsp;</span>

<br/>**Flashing the Firmware**

Connect the desired Atmel programmer to the header closer to the relays taking care to orient pin 1 properly (see Figure 8). The A140808 device needs to be powered on via an external power source in order for programming to work. Once all connections are made and the device is powered on, use one of the following programming commands. 

**Note:** The A140808 device must be powered on or programming will fail.

<p style="margin: 0"><span>&nbsp;</span></p>
<p style="padding-left: 1em; margin: 0">To Select the AVRISP mkII:</p>
{% highlight sh %}
cd device_a140808-master/avr
make avr-program
{% endhighlight %}

<p style="padding-left: 1em; margin: 0">To Select the MiniPro TL866A:</p>
{% highlight sh %}
cd device_a140808-master/avr
make mp-program
{% endhighlight %}

When the command finishes successfully, the Atmel programming is complete.

<br/>**Flashing the HiLink HLK-RM04**

The next step is to program the HLK-RM04. This step requires MiniPro TL866A and an 8 pin SOIC test clip. Start by identifying the flash memory on the HLK-RM04 device. The make and model of the flash memory is required when writing to the part. The part number is written on the chip itself. In my case the flash memory was covered with paint and required acetone and a cotton swab to remove. Using a smartphone to take a picture and zooming in, the part was identified as <a href="http://www.winbond.com/hq/product/code-storage-flash-memory/serial-nor-flash/?__locale=en&amp;partNo=W25Q32BV" target="_blank">Winbond W25Q32BV</a>. Another flash memory used by HiLink for the HLK-RM04 device is <a href="http://www.macronix.com/en-us/Product/Pages/ProductDetail.aspx?PartNo=MX25L3206E" target="_blank">Macronix MX25L3206E</a>

To get a list of possible part numbers the minipro software can program, use the <code>-l</code> command line option (with a grep filter in this case):

<p style="margin: 0"><span>&nbsp;</span></p>
<p style="padding-left: 1em; margin: 0">Winbond W25Q32BV:</p>
{% highlight sh %}
$ device_a140808-master/hlk-rm04/tools/minipro/minipro -l | grep W25Q32
W25Q32 @MLP8
W25Q32 @SOIC16
W25Q32BV
W25Q32BV @SOIC16
W25Q32BV @SOIC8
W25Q32BV @WSON8
W25Q32V @MLP8
W25Q32V @SOIC16
{% endhighlight %}

<p style="padding-left: 1em; margin: 0">Macronix MX25L3206E:</p>
{% highlight sh %}
$ device_a140808-master/hlk-rm04/tools/minipro/minipro -l | grep MX25L3206
MX25L3206E
MX25L3206E @SOP16
MX25L3206E @SOP8
MX25L3206E @USON8
MX25L3206E @WSON8
{% endhighlight %}

<p style="padding-left: 1em; margin: 0">If required, build the minipro binary first:</p>

{% highlight sh %}
$ cd device_a140808/hlk-rm04
$ make minipro
{% endhighlight %}

Multiple matching parts will likely be shown, but only the base part without the space will do the job. With the flash part number in-hand, it is time to proceed with programming. Clamp the test clip to the 8 pin flash memory module located on the bottom of the HLK-RM04 device taking care to orient pin 1 properly (see Figure 12).

<p style="margin: 0"><span>&nbsp;</span></p>
<center><table style="border-spacing: 10px; border-collapse: separate; font-size: 90%">
<tr><td><img width="380px" src="/images/f12_clip.jpg" /></td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Figure 12: SOIC Test Clip on Flash Memory Chip</td></tr>
</table></center>
<span>&nbsp;</span>

<p style="padding-left: 1em; margin: 0">Once connected, the part is ready to program.</p>

{% highlight sh %}
cd device_a140808-master/hlk-rm04
make program flash=W25Q32BV image=bin/a140808_akbmkzh80.bin
{% endhighlight %}

**Note:** The actual <code>image=</code> filename is build-specific and will be different than the one shown here.

Once the command successfully completes, the device is ready to boot. Insert the HLK-RM04 daughter card back into the A140808 main board. The pins are offset which prevents the device from being put in backwards, however, take care as to not misalign the pins along the socket.

<a class="anchor" id="booting_ssh"></a>
<span>&nbsp;</span>

###Booting and SSH

Once powered on, the red LED light on the HLK-RM04 should begin to blink as Linux begins to boot. Once the kernel is loaded the network indicator lights will begin to flash. The device is setup to automatically accept a DHCP issued TCP/IP address, so it is a simple matter to scan the network to find it. Perhaps the easiest way to find the IP address associated with the MAC address used above (see Figure 5) is to search the logs of the network DCHP server. Other options include network scanning apps such as Fing for Android, Lan Scan for OSX, or nmap for Linux:

{% highlight sh %}
nmap -sP 192.168.1.0/24 >/dev/null && arp -an | grep -i ac:a2:13:b5:4a:3e
{% endhighlight %}

Once the A140808 IP address is determined, use <code>ssh</code> to login to the device for final configuration. To login, use <code>root</code> for the userid and the password or certificate used in the [Building the Firmware](#building_firmware) step above.

<figure class="highlight"><pre style="background-color: #2a2a2a;"><code class="language-text" data-lang="text">$ ssh root@192.168.1.136
root@192.168.1.136's password:


BusyBox v1.19.4 (2015-10-01 01:02:10 EDT) built-in shell (ash)
Enter 'help' for a list of built-in commands.

<span style="color: #2188df; font-weight:bold">     ___  ___ ____ ___  ___  ___  ___
    / _ |&lt;  // / // _ \( _ )/ _ \( _ )
   / __ |/ //_  _/ // / _  / // / _  |
  /_/ |_/_/  /_/ \___/\___/\___/\___/
                   </span><span style="color: #777">powered by OpenWRT</span>


root@a140808:~#</code></pre></figure>


<a class="anchor" id="building_webserver"></a>
<span>&nbsp;</span>

###Building the Webserver

Bacon ipsum dolor amet turkey jerky rump tri-tip spare ribs. Cupim brisket landjaeger turkey. Picanha alcatra filet mignon meatball. Venison tail drumstick, tri-tip pork rump fatback spare ribs kevin. Sausage landjaeger boudin, rump bresaola prosciutto pork belly. Meatloaf short loin t-bone, alcatra tri-tip fatback pig ham.

<a class="anchor" id="building_android"></a>
<span>&nbsp;</span>

###Building Android

Bacon ipsum dolor amet landjaeger drumstick chicken jerky brisket shankle pancetta frankfurter ball tip short ribs beef porchetta. Frankfurter tenderloin strip steak tri-tip t-bone, cow pastrami kevin pork shoulder bresaola tail boudin pancetta ground round. Jowl ribeye short ribs, spare ribs kielbasa meatloaf t-bone doner shankle beef shoulder. Pig landjaeger pork, frankfurter kevin short ribs shankle drumstick brisket. Flank kielbasa chuck sirloin, drumstick boudin tenderloin picanha pastrami beef ribs.

<a class="anchor" id="conclusion"></a>
<span>&nbsp;</span>

###Conclusion

Bacon ipsum dolor amet tail boudin shank ball tip. Spare ribs capicola flank meatball picanha pork loin jowl swine drumstick tri-tip t-bone sirloin. Pastrami ribeye tri-tip, sausage ham tenderloin rump. Pork chop bacon pork loin biltong picanha short ribs alcatra. Venison pork loin filet mignon jerky, short ribs pastrami prosciutto shoulder tongue bacon sirloin. Tongue sausage capicola flank salami venison short ribs chicken shank fatback sirloin picanha frankfurter andouille. Shankle corned beef brisket fatback biltong capicola, pastrami pork.

<span>&nbsp;</span>


