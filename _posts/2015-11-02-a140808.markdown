---
layout:     post
title:      Hey Kids! Grow giant open source IoT controllers in your own basement!
subtitle:   Using off-the-shelf industrial-grade commodity hardware for sophisticated Internet of Things applications.
excerpt:    This is an open source project to connect an high durability but inexpensive 8 opto-isolated input / 8 relay output WiFi and Ethernet enabled controller via an encrypted websocket connection to the Internet. The configuration features an extremely low latency command and control architecture using Nginx or Redis based pubsub.
image:      businessman.png
image-px:   250
date:       2015-11-02 05:24:42 -0500
author:     John Clark
categories: a140808 iot opensource
---

###Table of Contents
  * [Introduction](#introduction)
  * [Getting Started](#getting_started)
  * [Security First](#security_first)
  * [Building Firmware](#building_firmware)
  * [Flashing Firmware](#flashing_firmware)
  * [Booting & SSH](#booting_ssh)
  * [Building Webserver](#building_webserver)
  * [Building Android](#building android)
  * [Conclusion](#conclusion)

<a class="anchor" id="introduction"></a>
<span>&nbsp;</span>

###Introduction
This is an open source project to connect an high durability yet inexpensive 8 opto-isolated input / 8 relay output WiFi and Ethernet enabled controller via an encrypted websocket connection to the Internet. The configuration features an extremely low latency command and control architecture using Nginx or Redis based pubsub. The result is a high quality yet extremely low cost solution with a huge number of IoT applications such as: simple on/off control, one-shot activation of devices like garage doors, state monitoring, Internet home thermostat, burglar alarm, and sprinkler system control to name only a few. The goal is to create an open source ecosystem of inexpensive commodity hardware and application software for a wide range of IoT command and control applications.

<span>&nbsp;</span>

**Physical Inspection**

The device used in this project is available from AliExpress for approximately $65 at the time of this writing. It comes with no useful documentation and its factory configuration is of limited value. There is no model number, so I decided to call it the A140808 which encodes the fact that I first bought it in 2014 and it has 08 inputs and 08 outputs.

<span>&nbsp;</span>
<center><table style="border-spacing: 10px; border-collapse: separate; font-size: 90%">
<tr><td><img width="500px" src="/images/f1_enclosure.jpg" /></td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Figure 1: The A140808 Device Enclosure with WiFi Antenna</td></tr>
</table></center>
<span>&nbsp;</span>

Upon examination of the outside of the device, we see that like most industrial automation equipment, it supports a wide range of voltages from 7v to 28v (Figure 1). Notice it does not specify AC or DC (examination of the buck converter later on shows that it is DC only).

The back of the enclosure (Figure 2) reveals more signs of its industrial automation purpose with the EN 50022 DIN mounting hardware.

<span>&nbsp;</span>
<center><table style="border-spacing: 10px; border-collapse: separate; font-size: 90%">
<tr><td><img width="450px" src="/images/f2_din.jpg" /></td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Figure 2: The A140808 DIN Mounting Clips</td></tr>
</table></center>
<span>&nbsp;</span>

**Teardown**

Removing the cover of the A140808 reveals two major components (Figure 3). The first is the main IO board sporting an <a href="http://www.atmel.com/Images/Atmel-8155-8-bit-Microcontroller-AVR-ATmega32A_Datasheet.pdf" target="_blank">Atmel ATmega32A</a> microcontroller. The ATmega32A is used to monitor the 8 opto-isolated inputs and to control the 8 relay outputs. The second major component is the <a href="http://www.hlktech.net/product_detail.php?ProId=39" target="_blank">Hi-Link HLK-RM04</a> Ethernet/WiFi/Serial module which runs embedded Linux. The brains of the HLK-RM04 is an Ralink RT5350 SOC clocked at 360MHz. Ralink was purchased by MediaTek in 2011 and documentation for the SOC became very difficult to find for some reason. Fortunately, Jiapeng Li has created <a href="https://github.com/JiapengLi" target="_blank">OpenWRT support</a> for the HLK-RM04 module we will lean on later in the article.

<span>&nbsp;</span>
<center><table style="border-spacing: 10px; border-collapse: separate; font-size: 90%">
<tr><td><img width="600px" src="/images/f3_comp.jpg" /></td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Figure 3: Components of the A140808</td></tr>
</table></center>
<span>&nbsp;</span>

Removing the socketed HLK-RM04 reveals the Atmel ATmega32A microcontroller (figure 4). Note that the microcontroller also has a six pin ICSP programming header for our convenience. Unfortunately the header pinout is NOT AVR-ICSP compatible, so we will be building a custom wiring harness later on. It is also worth noting that the ATmega32A is very similar to the ATmega328P used on the Arduino UNO and the ATmega32U4 used on the Arduino Leonardo. We will be using the Arduino SDK to program this chip later on.

<span>&nbsp;</span>
<center><table style="border-spacing: 10px; border-collapse: separate; font-size: 90%">
<tr><td><img width="650px" src="/images/f4_prog.jpg" /></td></tr>
<tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Figure 4: Atmel ATmega32A and Six Pin Programming Header</td></tr>
</table></center>
<span>&nbsp;</span>

Looking at what all is included in this commercial quality device with WiFi, Ethernet, Ralink RT5350 SOC, Atmel ATmega32A, 8 opto-isolated inputs, 8 relay outputs, screw terminal connectors, DIN mounts, and a wide input voltage range of 7-28VDC, the A140808 is an incredible platform for open source IoT projects.

<a class="anchor" id="getting_started"></a>
<span>&nbsp;</span>

###Getting Started

<br/>**Linux Build Environment**

The makefiles and shell scripts for this project are written for Linux. If you are not already setup to use Linux, the easiest way to do so is to either use <a href="https://www.virtualbox.org" target="_blank">VirtualBox</a> with <a href="https://www.vagrantup.com" target="_blank">Vagrant</a> or use the <a href="https://aws.amazon.com/free" target="_blank">Amazon AWS Free Tier</a> to build this project. Linux distributions such as Debian, Ubuntu, RedHat, CentOS, and Amazon Linux are all excellent choices and each are similarly easy to use for this project. It is beyond the scope of this document to provide information on setting up or using Linux. If you are unfamiliar with Linux, it is best to get a friend to help you out or read one of the <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EC2_GetStarted.html" target="_blank">excellent tutorials</a> found online.

<span>&nbsp;</span>

Ubuntu Trusty 14.04 requires the following prerequisites:

{% highlight sh %}
sudo apt-get update && sudo apt-get upgrade
sudo apt-get install make gcc g++ libncurses5-dev zlib1g-dev unzip git subversion docker
{% endhighlight %}

Amazon Linux requires the following prerequisites:

{% highlight sh %}
sudo yum update
sudo yum install gcc gcc-c++ ncurses-devel zlib-devel patch  perl\(Data::Dumper\) git subversion docker
{% endhighlight %}

<a class="anchor" id="security_first"></a>
<span>&nbsp;</span>

###Security First

Comprehensive security is a primary concern of IoT applications. This project utilizes well established RSA asymmetric encryption deployed with high strength 4096 bit keys. Additionally, the signed URL design combines HMAC hashing using the high security SHA256 algorithm (HMAC-SHA256) and are narrowly limited in time. In the near future the signed URL implementation will also add adaptive complexity and salting similar to that which is found in the <a href="https://en.wikipedia.org/wiki/Bcrypt" target="_blank">bcrypt</a> key derivation function implementation.

The first step is to generate a self-signed Certificate Authority (CA) which will be built into the A140808 client device, smart phone client devices (TODO: doc custom smartphone CA), as well as the server. This approach allows us to sign our own certificates and establish a tight client-server security contract extremely resistant to <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" target="_blank">man-in-the-middle-attacks</a>. Not only is this approach free, if properly deployed, it can be more secure than using a 3rd party CA that is susceptible to <a href="https://en.wikipedia.org/wiki/DigiNotar" target="_blank">hacking</a> or <a href="https://googleonlinesecurity.blogspot.com/2015/03/maintaining-digital-certificate-security.html" target="_blank">improper management</a>, or <a href="http://www.pcworld.com/article/249510/trustwave_admits_issuing_maninthemiddle_digital_certificate_mozilla_debates_punishment.html" target="_blank">poor judgement</a>. However, it is important to note that the certificate strategy does not preclude the use of certificates signed by well-known CAs.

<br/>**Generate the Certificate Authority**

If you are comfortable generating your own self-signed CA and a certificate signed by this CA, do so now. Alternatively, you can use the two helper scripts gen_ca.sh and gen_cert.sh to simplify this process. Begin by downloading the scripts to a Linux machine:

{% highlight sh %}
wget -O certs.tar.gz https://github.com/rest-switch/stuff/archive/master.tar.gz
tar xzvf certs.tar.gz
cd stuff-master/certs
{% endhighlight %}

Generate the self-signed CA by specifying the CA organization name. The script will default to  a key length setting of 4096 bits and a 10 year expiration. Use the --help command line switch to view the syntax for overriding these default options.

{% highlight sh %}
    ./gen_ca.sh "Acme Co"
{% endhighlight %}

When the script completes, it will emit the name of the public and private CA keys that were generated. This CA will be used to sign the certificate in the next step.

{% highlight sh %}
--> generated ca public cert:  acme-co_ca_public.cer
--> generated ca private key:  acme-co_ca_private
{% endhighlight %}

**Generate the Certificate**

The certificate that will be used to encrypt the websocket and https traffic to the web server requires specific information. It is not necessary to generate the certificate public / private key pair at this time, but if the web server domain name(s) are known, it is a convenient time to do so now using the gen_cert.sh script.

For example, to connect to the server using example.com, ws.example.com, and www.example.com, use the following syntax (see the --help command line switch to view all of the command line options):

{% highlight sh %}
./gen_cert.sh -o "Acme Co" -d example.com -a "example.com ws.example.com www.example.com" -c "San Diego" -s CA -u acme-co_ca_public.cer -v acme-co_ca_private
{% endhighlight %}

When the script completes, it will emit the name of the public and private keys that were generated. For convenience, the script also emits a combined public certificate / CA chain file suitable for use with Nginx:

{% highlight sh %}
--> generated cert public cert:  acme-co_cert_public.cer
--> generated cert public cert chain:  acme-co_cert_chain_public.cer
--> generated cert private key:  acme-co_cert_private
{% endhighlight %}

The certificates needed for the entire project are now generated. It is easy to come back and generate new certificates as needed. It should also be noted that the A140808 device is setup to use multiple CAs and more than one can be generated at this point if so desired.

In the next step, the A140808 device image will be built and the public CA file(s) generated in this step will become part of the device firmware image itself. The details are provided in the next section, but for reference the firmware root CA staging directory is:

{% highlight sh %}
device_a140808-master/hlk-rm04/ca_certs
{% endhighlight %}

**Certificate Review**

In summary, the following certificate files and their use are as follows:

> <code style="font-size: 14px; padding: 6px 10px; margin: 0px 0px 10px">--&gt; generated ca public cert:  acme-co_ca_public.cer</code>
>
> The public certificate for the CA. This is used to validate the identity of subordinate certificates in the trust chain. In the case of this project both the A140808 device and the web server need to have access to a genuine copy of this certificate file.

> <code style="font-size: 14px; padding: 6px 10px; margin: 0px 0px 10px">--&gt; generated ca private key:  acme-co_ca_private</code>
>
> The private certificate for the CA. This certificate is only used to sign certificate signing requests (CSRs). The privacy of this key is paramount to the integrity of the entire certificate trust chain and should be securely stored <a href="https://www.thawte.com/code-signing/whitepaper/best-practices-for-code-signing-certificates.pdf" target="_blank">using best practices</a>.

> <code style="font-size: 14px; padding: 6px 10px; margin: 0px 0px 10px">--&gt; generated cert public cert:  acme-co_cert_public.cer</code>
>
> This is the main public certificate is used to encrypt data between the client and the server. Clients need to trust the CA that signed this certificate or trust the certificate itself if it is a self-signed certificate.

> <code style="font-size: 14px; padding: 6px 10px; margin: 0px 0px 10px">--&gt; generated cert public cert chain:  acme-co_cert_chain_public.cer</code>
>
> This file is a combination of the public certificate and the public root CA certificates suitable for loading in Nginx. The point of this file is to be able to supply the non-well-known public certificate trust chain to clients at connect time.

> <code style="font-size: 14px; padding: 6px 10px; margin: 0px 0px 10px">--&gt; generated cert private key:  acme-co_cert_private</code>
>
> The private certificate key for decrypting SSL communication at the server. This file must be present and kept secret on the web server.

Make a note of where these files are located as they will be used in the next steps to build the A140808 firmware and will be deployed with the Nginx web server Docker container.

<a class="anchor" id="building_firmware"></a>
<span>&nbsp;</span>

###Building Firmware

<br/>**Project Repository**

Download the A140808 github repository and extract it:

{% highlight sh %}
wget -O device_a140808.tar.gz https://github.com/rest-switch/device_a140808/archive/master.tar.gz
tar xzvf device_a140808.tar.gz
cd device_a140808-master
{% endhighlight %}

The repository contains two subdirectories. The avr directory contains the complete project for building the firmware for the Atmel ATmega32A. Likewise, the hlk-rm04 directory contains the complete project for building the firmware for the Hi-Link HLK-RM04 module.

{% highlight sh %}
[device_a140808-master]$ ls -al
drwxrwxr-x 3 ec2-user ec2-user 4096 Oct  8 14:26 avr
drwxrwxr-x 5 ec2-user ec2-user 4096 Oct  8 14:26 hlk-rm04
-rw-rw-r-- 1 ec2-user ec2-user 1016 Oct  8 14:26 Makefile
-rw-rw-r-- 1 ec2-user ec2-user 1200 Oct  8 14:26 README.md
{% endhighlight %}

Executing make in the <code>device_a140808-master</code> directory will build both projects, or you can descend into either directory and execute <code>make</code> to build that project alone.


<br/>**Building the Atmel ATmega32A Firmware**

Switch to the <code>device_a140808-master/avr</code> directory and type <code>make</code>. The build will complete very quickly and the target binaries will be placed into the <code>bin</code> directory. The files of interest are <code>a140808.hex</code> or <code>a140808.bin</code> depending on the programmer used to flash the device.

{% highlight sh %}
[avr]$ ls -al bin
-rwxrwxr-x 1 ec2-user ec2-user  32768 Oct 23 19:14 a140808.bin
-rw-rw-r-- 1 ec2-user ec2-user     13 Oct 23 19:14 a140808.eep
-rwxrwxr-x 1 ec2-user ec2-user  51387 Oct 23 19:14 a140808.elf
-rw-rw-r-- 1 ec2-user ec2-user  14999 Oct 23 19:14 a140808.hex
-rw-rw-r-- 1 ec2-user ec2-user 141167 Oct 23 19:14 a140808.lss
-rw-rw-r-- 1 ec2-user ec2-user  34626 Oct 23 19:14 a140808.map
-rw-rw-r-- 1 ec2-user ec2-user  36320 Oct 23 19:14 avr_impl.o
-rw-rw-r-- 1 ec2-user ec2-user   2825 Oct 23 19:14 avr_impl.o.dep
-rw-rw-r-- 1 ec2-user ec2-user  41412 Oct 23 19:14 avr_main.o
-rw-rw-r-- 1 ec2-user ec2-user   2996 Oct 23 19:14 avr_main.o.dep
-rw-rw-r-- 1 ec2-user ec2-user     55 Oct 23 19:14 fuses.conf
-rw-rw-r-- 1 ec2-user ec2-user  26808 Oct 23 19:14 serial.o
-rw-rw-r-- 1 ec2-user ec2-user   2452 Oct 23 19:14 serial.o.dep
{% endhighlight %}

In a subsequent section, the source files and theory of operation will be discussed in greater detail. However, at this point this is all that is needed to be able to flash the ATmega32A device. Building the HLK-RM04 device is up next.

<br/>**Building the Atmel HLK-RM04 Firmware**

The Hi-Link HLK-RM04 module runs OpenWRT Linux. Additional information on OpenWRT and the Hi-Link device can be found on the OpenWRT wiki. Before building the firmware, the CA certificates build previously need to be copied to the project directory to be included in the resulting firmware image. Change to the device_a140808-master/hlk-rm04 directory and list the files.

{% highlight sh %}
[hlk-rm04]$ ls -al
drwxrwxr-x  2 ec2-user ec2-user 4096 Oct 23 10:10 ca_certs
drwxrwxr-x  3 ec2-user ec2-user 4096 Oct 23 10:03 files
drwxrwxr-x  2 ec2-user ec2-user 4096 Oct 23 10:03 firmware
-rw-rw-r--  1 ec2-user ec2-user 8442 Oct 23 10:03 Makefile
drwxrwxr-x 15 ec2-user ec2-user 4096 Oct 23 12:18 openwrt-master
drwxrwxr-x  5 ec2-user ec2-user 4096 Oct 23 10:03 tools
{% endhighlight %}

**Copy CA Public Certificates**

Take note of the <code>ca_certs</code> directory which is the location where the CA certificate that were generated earlier belong. Note that the firmware image only requires the public CA file(s). The build script will copy all files ending in <code>_ca_public.cer</code> to the firmware image so following this naming convention is required.

<br/>**SSH Access**

Next, the type of SSH access for the device needs to be considered. It is also possible to configure no SSH access. Certificates based SSH authentication is considered more secure, but password based authentication is also available. It is possible to configure both types of authentication then lockout the password based authentication mechanism at a later time as well. There is no great way to recover access if the certificate is lost or the password is forgotten, so regaining access would require reflashing the firmware. This is an open source project, and OpenWRT does make provisions for password recovery, so this could make a nice enhancement to the project. In general, questions regarding the HLK-RM04 device can easily be searched on the OpenWRT website.

On the command line, include one or more of the options desired. For example, to compile with password access and have the build process prompt (pmt) for the password, type:

{% highlight sh %}
make sshpw=pmt
{% endhighlight %}

To configure a password directly (“mysecret” in this example) and to bundle a newly generated SSH cert file, type:

{% highlight sh %}
make sshpw=mysecret sshcert=gen
{% endhighlight %}

{% highlight sh %}
Note that some options are mutually exclusive with each other. The full listing of options is as follows:
no ssh access: ssh=none
no ssh password access: sshpw=none
ssh password access (prompt): sshpw=pmt
ssh password access: sshpw=<password>
no ssh certificate access: sshcert=none
ssh certificate access, create new cert: sshcert=gen
ssh certificate access, use existing cert: sshcert=<filespec>
{% endhighlight %}

**Note:** If the build fails early before the .config configuration file can be generated, it is possible to get stuck at the Linux kernel config (blue) menu. You should never see this menu in a normal build. If this happens run a make distclean and restart the build from scratch.

**Tip:** Long-running builds will fail if the terminal session gets disconnected. Launch the screen utility to allow the build to continue even of the terminal session becomes disconnected. If the terminal session does become detached, reconnect to the Linux host and execute screen -r to reattach to the running session.

After the build finishes successfully, the firmware file <code>openwrt-ramips-rt305x-hlk-rm04-squashfs-sysupgrade.bin</code> will be placed into the bin directory. For details on the sysupgrade.bin file, refer to the <a href="http://wiki.openwrt.org/doc/howto/generic.sysupgrade" target="_blank">OpenwWRT wiki</a>. The sysupgrade file does not include a bootloader, so it can only be used to update an already running A140808 device. In the later sections of the documentation, instructions for doing so are included. In the case of a new device, it is necessary to build a full firmware image which takes a few more steps.

<br/>**Adding u-boot**

In order to be able to flash the device using a flash programmer, a complete firmware image file is required. In this case, the u-boot that ships with the HLK-RM04 can be used in conjunction with the MAC addresses printed on the front of the device (Figure 5).

<span>&nbsp;</span>
<center><table style="border-spacing: 10px; border-collapse: separate; font-size: 90%">
<tr><td><img width="350px" src="/images/f5_hlkrm04.jpg" /></td></tr>
<tr><td>Figure 5: The HLK-RM04 Module with MAC Addresses</td></tr>
</table></center>
<span>&nbsp;</span>


Notice that the MAC addresses are consecutive. To specify a MAC address and generate the full image firmware, use the <code>make image mac=aabbccddeeff</code> command and specify the first MAC address listed on your device. For example:

{% highlight sh %}
make image mac=aca213b54a3e
{% endhighlight %}

This will generate a full image firmware file with a unique serial number, for example:

{% highlight sh %}
bin/a140808_akbmkzh80.bin
{% endhighlight %}

The serial number is a nine character alphanumeric code following the underscore. In the case above, the serial number is <code>akbmkzh80</code>. This code is important and will be used to uniquely identify the device when it connects to the cloud.

The firmware generation for the HLM-RM04 is now complete. In the next section the firmware for the two chips will be written to their respective devices.




<a class="anchor" id="flashing_firmware"></a>
<span>&nbsp;</span>

###Flashing Firmware

Bacon ipsum dolor amet pork picanha sausage turducken meatloaf venison. Pancetta pork alcatra ball tip cupim tail turducken rump shank drumstick doner meatball chicken picanha sirloin. Venison sausage shoulder t-bone tongue turkey shankle doner boudin pastrami flank short loin. Bacon pork jowl brisket short loin sausage, salami turducken beef rump. Fatback tongue prosciutto venison, alcatra pork chicken tenderloin ball tip filet mignon.

<a class="anchor" id="booting_ssh"></a>
<span>&nbsp;</span>

###Booting & SSH

Bacon ipsum dolor amet brisket chuck pork chop, ham hock beef leberkas tenderloin kevin spare ribs venison frankfurter kielbasa pig alcatra sausage. Boudin cow short loin filet mignon turducken. Boudin sirloin tri-tip meatball brisket chicken ham frankfurter venison tongue meatloaf spare ribs tail fatback. Pork belly pancetta alcatra, t-bone meatball salami tenderloin short loin pork loin swine kevin shoulder. Pig ground round kielbasa turkey rump pancetta tenderloin pork chop porchetta. Andouille pork loin pork, hamburger strip steak boudin meatloaf short loin cupim tri-tip shoulder beef pastrami kielbasa.

<a class="anchor" id="building_webserver"></a>
<span>&nbsp;</span>

###Building Webserver

Bacon ipsum dolor amet turkey jerky rump tri-tip spare ribs. Cupim brisket landjaeger turkey. Picanha alcatra filet mignon meatball. Venison tail drumstick, tri-tip pork rump fatback spare ribs kevin. Sausage landjaeger boudin, rump bresaola prosciutto pork belly. Meatloaf short loin t-bone, alcatra tri-tip fatback pig ham.

<a class="anchor" id="building_android"></a>
<span>&nbsp;</span>

###Building Android

Bacon ipsum dolor amet landjaeger drumstick chicken jerky brisket shankle pancetta frankfurter ball tip short ribs beef porchetta. Frankfurter tenderloin strip steak tri-tip t-bone, cow pastrami kevin pork shoulder bresaola tail boudin pancetta ground round. Jowl ribeye short ribs, spare ribs kielbasa meatloaf t-bone doner shankle beef shoulder. Pig landjaeger pork, frankfurter kevin short ribs shankle drumstick brisket. Flank kielbasa chuck sirloin, drumstick boudin tenderloin picanha pastrami beef ribs.

<a class="anchor" id="conclusion"></a>
<span>&nbsp;</span>

###Conclusion

Bacon ipsum dolor amet tail boudin shank ball tip. Spare ribs capicola flank meatball picanha pork loin jowl swine drumstick tri-tip t-bone sirloin. Pastrami ribeye tri-tip, sausage ham tenderloin rump. Pork chop bacon pork loin biltong picanha short ribs alcatra. Venison pork loin filet mignon jerky, short ribs pastrami prosciutto shoulder tongue bacon sirloin. Tongue sausage capicola flank salami venison short ribs chicken shank fatback sirloin picanha frankfurter andouille. Shankle corned beef brisket fatback biltong capicola, pastrami pork.

<span>&nbsp;</span>


